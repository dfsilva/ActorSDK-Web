{"version":3,"sources":["../../src/dispatcher/ActorAppDispatcher.js"],"names":["register","waitFor","dispatch","dispatchAsync","flux","callback","ids","type","action","Error","process","env","NODE_ENV","LOGGER_APPEND","error","console","info","Promise","reject","resolve","response","logError","bind","promise","types","request","success","failure","then","catch"],"mappings":";;;;;;QAKgBA,Q,GAAAA,Q;QAIAC,O,GAAAA,O;QAYAC,Q,GAAAA,Q;QAoCAC,a,GAAAA,a;;AAzDhB;;AACA;;AAEA,IAAMC,OAAO,sBAAb;;AAEO,SAASJ,QAAT,CAAkBK,QAAlB,EAA4B;AACjC,SAAOD,KAAKJ,QAAL,CAAcK,QAAd,CAAP;AACD;;AAEM,SAASJ,OAAT,CAAiBK,GAAjB,EAAsB;AAC3B,SAAOF,KAAKH,OAAL,CAAaK,GAAb,CAAP;AACD;;AAED;AACA;AACA;AACA;;AAEA;;;AAGO,SAASJ,QAAT,CAAkBK,IAAlB,EAAqC;AAAA,MAAbC,MAAa,uEAAJ,EAAI;;AAC1C,MAAI,CAACD,IAAL,EAAW;AACT,UAAM,IAAIE,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAED;AACA;AACA;AACA,MAAIC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC;AACA;AACA;AACA;AACA,QAAIL,SAAS,+BAAYM,aAAzB,EAAwC;AACtC,UAAIL,OAAOM,KAAX,EAAkB;AAChBC,gBAAQD,KAAR,CAAcP,IAAd,EAAoBC,MAApB;AACD,OAFD,MAEO;AACLO,gBAAQC,IAAR,CAAaT,IAAb,EAAmBC,MAAnB;AACD;AACF;AACF;;AAEDJ,OAAKF,QAAL,YAAgBK,UAAhB,IAAyBC,MAAzB;;AAEA,MAAIA,OAAOM,KAAX,EAAkB;AAChB,WAAOG,QAAQC,MAAR,CAAeV,OAAOM,KAAtB,CAAP;AACD;;AAED,SAAOG,QAAQE,OAAR,CAAgBX,OAAOY,QAAP,GAAkBZ,OAAOY,QAAzB,GAAoCZ,MAApD,CAAP;AACD;;AAED,IAAMa,WAAWN,QAAQD,KAAR,CAAcQ,IAAd,CAAmBP,OAAnB,CAAjB;;AAEA;;;AAGO,SAASZ,aAAT,CAAuBoB,OAAvB,EAAgCC,KAAhC,EAAoD;AAAA,MAAbhB,MAAa,uEAAJ,EAAI;AAAA,MACjDiB,OADiD,GACnBD,KADmB,CACjDC,OADiD;AAAA,MACxCC,OADwC,GACnBF,KADmB,CACxCE,OADwC;AAAA,MAC/BC,OAD+B,GACnBH,KADmB,CAC/BG,OAD+B;;;AAGzDzB,WAASuB,OAAT,EAAkBjB,MAAlB;AACA,SAAOe,QAAQK,IAAR,CACL;AAAA,WAAY1B,SAASwB,OAAT,eAAuBlB,MAAvB,IAA+BY,kBAA/B,IAAZ;AAAA,GADK,EAEL;AAAA,WAASlB,SAASyB,OAAT,eAAuBnB,MAAvB,IAA+BM,YAA/B,IAAT;AAAA,GAFK,EAGLe,KAHK,CAGCR,QAHD,CAAP;AAID;;kBAEcjB,I","file":"ActorAppDispatcher.js","sourcesContent":["import { Dispatcher } from 'flux';\nimport { ActionTypes } from '../constants/ActorAppConstants';\n\nconst flux = new Dispatcher();\n\nexport function register(callback) {\n  return flux.register(callback);\n}\n\nexport function waitFor(ids) {\n  return flux.waitFor(ids);\n}\n\n// Some Flux examples have methods like `handleViewAction`\n// or `handleServerAction` here. They are only useful if you\n// want to have extra pre-processing or logging for such actions,\n// but I found no need for them.\n\n/**\n * Dispatches a single action.\n */\nexport function dispatch(type, action = {}) {\n  if (!type) {\n    throw new Error('You forgot to specify type.');\n  }\n\n  // In production, thanks to DefinePlugin in webpack.config.production.js,\n  // this comparison will turn `false`, and UglifyJS will cut logging out\n  // as part of dead code elimination.\n  if (process.env.NODE_ENV !== 'production') {\n    // Logging all actions is useful for figuring out mistakes in code.\n    // All data that flows into our application comes in form of actions.\n    // Actions are just plain JavaScript objects describing “what happened”.\n    // Think of them as newspapers.\n    if (type !== ActionTypes.LOGGER_APPEND) {\n      if (action.error) {\n        console.error(type, action);\n      } else {\n        console.info(type, action);\n      }\n    }\n  }\n\n  flux.dispatch({ type, ...action });\n  \n  if (action.error) {\n    return Promise.reject(action.error);\n  }\n\n  return Promise.resolve(action.response ? action.response : action);\n}\n\nconst logError = console.error.bind(console);\n\n/**\n * Dispatches three actions for an async operation represented by promise.\n */\nexport function dispatchAsync(promise, types, action = {}) {\n  const { request, success, failure } = types;\n\n  dispatch(request, action);\n  return promise.then(\n    response => dispatch(success, { ...action, response }),\n    error => dispatch(failure, { ...action, error })\n  ).catch(logError);\n}\n\nexport default flux;\n"]}