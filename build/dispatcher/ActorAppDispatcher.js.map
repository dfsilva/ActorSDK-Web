{"version":3,"sources":["../../src/dispatcher/ActorAppDispatcher.js"],"names":["register","waitFor","dispatch","dispatchAsync","flux","callback","ids","type","action","Error","process","env","NODE_ENV","LOGGER_APPEND","error","console","info","Promise","reject","resolve","response","logError","bind","promise","types","request","success","failure","then","catch"],"mappings":";;;;;;QAKgBA,Q,GAAAA,Q;QAIAC,O,GAAAA,O;QAYAC,Q,GAAAA,Q;QAoCAC,a,GAAAA,a;;AAzDhB;;AACA;;AAEA,IAAMC,OAAO,sBAAb;;AAEO,SAASJ,QAAT,CAAkBK,QAAlB,EAA4B;AACjC,SAAOD,KAAKJ,QAAL,CAAcK,QAAd,CAAP;AACD;;AAEM,SAASJ,OAAT,CAAiBK,GAAjB,EAAsB;AAC3B,SAAOF,KAAKH,OAAL,CAAaK,GAAb,CAAP;AACD;;AAED;AACA;AACA;AACA;;AAEA;;;AAGO,SAASJ,QAAT,CAAkBK,IAAlB,EAAqC;AAAA,MAAbC,MAAa,uEAAJ,EAAI;;AAC1C,MAAI,CAACD,IAAL,EAAW;AACT,UAAM,IAAIE,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAED;AACA;AACA;AACA,MAAIC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC;AACA;AACA;AACA;AACA,QAAIL,SAAS,+BAAYM,aAAzB,EAAwC;AACtC,UAAIL,OAAOM,KAAX,EAAkB;AAChBC,gBAAQD,KAAR,CAAcP,IAAd,EAAoBC,MAApB;AACD,OAFD,MAEO;AACLO,gBAAQC,IAAR,CAAaT,IAAb,EAAmBC,MAAnB;AACD;AACF;AACF;;AAEDJ,OAAKF,QAAL,YAAgBK,UAAhB,IAAyBC,MAAzB;;AAEA,MAAIA,OAAOM,KAAX,EAAkB;AAChB,WAAOG,QAAQC,MAAR,CAAeV,OAAOM,KAAtB,CAAP;AACD;;AAED,SAAOG,QAAQE,OAAR,CAAgBX,OAAOY,QAAP,GAAkBZ,OAAOY,QAAzB,GAAoCZ,MAApD,CAAP;AACD;;AAED,IAAMa,WAAWN,QAAQD,KAAR,CAAcQ,IAAd,CAAmBP,OAAnB,CAAjB;;AAEA;;;AAGO,SAASZ,aAAT,CAAuBoB,OAAvB,EAAgCC,KAAhC,EAAoD;AAAA,MAAbhB,MAAa,uEAAJ,EAAI;AAAA,MACjDiB,OADiD,GACnBD,KADmB,CACjDC,OADiD;AAAA,MACxCC,OADwC,GACnBF,KADmB,CACxCE,OADwC;AAAA,MAC/BC,OAD+B,GACnBH,KADmB,CAC/BG,OAD+B;;;AAGzDzB,WAASuB,OAAT,EAAkBjB,MAAlB;AACA,SAAOe,QAAQK,IAAR,CACL;AAAA,WAAY1B,SAASwB,OAAT,eAAuBlB,MAAvB,IAA+BY,kBAA/B,IAAZ;AAAA,GADK,EAEL;AAAA,WAASlB,SAASyB,OAAT,eAAuBnB,MAAvB,IAA+BM,YAA/B,IAAT;AAAA,GAFK,EAGLe,KAHK,CAGCR,QAHD,CAAP;AAID;;kBAEcjB,I","file":"ActorAppDispatcher.js","sourcesContent":["import { Dispatcher } from 'flux';\r\nimport { ActionTypes } from '../constants/ActorAppConstants';\r\n\r\nconst flux = new Dispatcher();\r\n\r\nexport function register(callback) {\r\n  return flux.register(callback);\r\n}\r\n\r\nexport function waitFor(ids) {\r\n  return flux.waitFor(ids);\r\n}\r\n\r\n// Some Flux examples have methods like `handleViewAction`\r\n// or `handleServerAction` here. They are only useful if you\r\n// want to have extra pre-processing or logging for such actions,\r\n// but I found no need for them.\r\n\r\n/**\r\n * Dispatches a single action.\r\n */\r\nexport function dispatch(type, action = {}) {\r\n  if (!type) {\r\n    throw new Error('You forgot to specify type.');\r\n  }\r\n\r\n  // In production, thanks to DefinePlugin in webpack.config.production.js,\r\n  // this comparison will turn `false`, and UglifyJS will cut logging out\r\n  // as part of dead code elimination.\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    // Logging all actions is useful for figuring out mistakes in code.\r\n    // All data that flows into our application comes in form of actions.\r\n    // Actions are just plain JavaScript objects describing “what happened”.\r\n    // Think of them as newspapers.\r\n    if (type !== ActionTypes.LOGGER_APPEND) {\r\n      if (action.error) {\r\n        console.error(type, action);\r\n      } else {\r\n        console.info(type, action);\r\n      }\r\n    }\r\n  }\r\n\r\n  flux.dispatch({ type, ...action });\r\n  \r\n  if (action.error) {\r\n    return Promise.reject(action.error);\r\n  }\r\n\r\n  return Promise.resolve(action.response ? action.response : action);\r\n}\r\n\r\nconst logError = console.error.bind(console);\r\n\r\n/**\r\n * Dispatches three actions for an async operation represented by promise.\r\n */\r\nexport function dispatchAsync(promise, types, action = {}) {\r\n  const { request, success, failure } = types;\r\n\r\n  dispatch(request, action);\r\n  return promise.then(\r\n    response => dispatch(success, { ...action, response }),\r\n    error => dispatch(failure, { ...action, error })\r\n  ).catch(logError);\r\n}\r\n\r\nexport default flux;\r\n"]}